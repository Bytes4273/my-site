// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

contract Byte$ is ERC1155 {
    using Strings for uint256;

    address public admin;
    address public blueFund;

    // Definindo as cedulas válidas
    string[] public validCedulas = [
        "0.05-c", "0.10-c", "0.25-c", "0.50-c", 
        "1-r$", "2-r$", "5-r$", "10-r$", 
        "20-r$", "50-r$", "100-r$", "200-r$"
    ];

    mapping(string => bool) private _avatarNameExists;
    mapping(address => bool) public usuariosPremium;
    mapping(address => uint256) private _stakingBalances;
    mapping(address => uint256) private _stakingTimestamps;
    mapping(address => string) private _avatars;
    mapping(address => string) private _names;
    mapping(address => bool) private _isNamePublic;
    mapping(string => bool) private _nameExists;
    mapping(uint256 => Proposal) public proposals;
    mapping(address => uint256[]) private _userTokenIds; 
    mapping(address => uint256) private _avatarIds; 
    mapping(uint256 => mapping(address => bool)) private _hasVoted;
    mapping(address => uint256) private _avatarCount; 
    mapping(address => uint256) private _lastActive;
    
    // Mapeamento privado para limites de mintagem
    mapping(string => uint256) private mintLimits;
    mapping(string => uint256) public totalMinted;
    
    uint256 public proposalCount;
    uint256 public burnRate = 1;
    uint256 private _stakingRewardRate = 9;
    uint256 private constant _maxStakePerValidator = 10000 * 10 ** 8;
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    struct MintInfo {
        string serie;
        string observacoes;
        string familia;
    }

    mapping(string => MintInfo) public mintInfos;

    bool private _locked;
    
    enum ProposalStatus { Pending, Executed, InAnalysis, Cancelled }
    
    struct Proposal {
        uint256 id;
        string description;
        uint256 votesFor;
        uint256 votesAgainst;
        uint256 deadline;
        bool executed;
        uint256 amount;
        address ownerA;
        address ownerB;
        ProposalStatus status;
    }

    event StakingRewardRateUpdated(uint256 newRate);
    event Stake(address indexed user, uint256 amount);
    event WithdrawStake(address indexed user, uint256 amount);
    event TokensBurned(address indexed from, uint256 amount);
    event ProposalCreated(uint256 id, string description, uint256 deadline);
    event Voted(uint256 proposalId, address indexed voter, bool support);
    event UserInfoUpdated(address indexed user, string avatar, string name, bool isPublic);
    event UsuarioPremiumDefinido(address usuario);
    event AvatarMinted(address indexed user, uint256 avatarId);
    event ProposalExecuted(uint256 proposalId, address recipient, uint256 amount);
    event ProposalAutomaticallyExecuted(uint256 proposalId, address recipient, uint256 amount);

    modifier noReentrancy() {
        require(!_locked, "Byte$: Reentrancy detected");
        _locked = true;
        _;
        _locked = false;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, "Acesso negado: apenas admin pode executar esta funcao.");
        _;
    }

    constructor(address initialBlueFund) ERC1155("https://api.byte.com/metadata/{id}/{serie}.json") {
        require(initialBlueFund != address(0), "Byte$: Invalid blue fund address");
        admin = msg.sender;
        _name = " Byte$";
        _symbol = "BT$";
        _decimals = 8;
        _totalSupply = 215000000000 * 10 ** _decimals;
        blueFund = initialBlueFund;
        _mint(msg.sender, 0, 200000, "");

        // Inicializando os limites de mintagem
        mintLimits["0.05-c"] = 8000000000;
        mintLimits["0.10-c"] = 7000000000;
        mintLimits["0.25-c"] = 3000000000;
        mintLimits["0.50-c"] = 3000000000;
        mintLimits["1-r$"] = 4000000000;
        mintLimits["2-r$"] = 1000000000;
        mintLimits["5-r$"] = 600000000;
        mintLimits["10-r$"] = 600000000;
        mintLimits["20-r$"] = 700000000;
        mintLimits["50-r$"] = 1000000000;
        mintLimits["100-r$"] = 2000000000;
        mintLimits["200-r$"] = 100000000;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function mintByte(string memory cedula, uint256 amount, string memory serie, string memory observacoes) public onlyAdmin {
        require(amount > 0, "Byte$: Amount must be greater than zero");
        require(isValidCedula(cedula), "Byte$: Invalid cedula");
        require(totalMinted[cedula] + amount <= mintLimits[cedula], "Byte$: Minting limit exceeded for this cedula");

        _mint(msg.sender, 0, amount, "");
        totalMinted[cedula] += amount;
        _totalSupply += amount;

        mintInfos[cedula] = MintInfo({
            serie: serie,
            observacoes: observacoes,
            familia: "ByteS"
        });
    }

    function isValidCedula(string memory cedula) internal view returns (bool) {
        for (uint256 i = 0; i < validCedulas.length; i++) {
            if (keccak256(abi.encodePacked(validCedulas[i])) == keccak256(abi.encodePacked(cedula))) {
                return true;
            }
        }
        return false;
    }

    function getBlueFundBalance() public view returns (uint256) {
        return balanceOf(blueFund, 0);
    }

    function getAllBalancesOfUser (address user) public view returns (uint256[] memory) {
        uint256[] memory tokenIds = _userTokenIds[user];
        uint256[] memory balances = new uint256[](tokenIds.length);

        for (uint256 i = 0; i < tokenIds.length; i++) {
            balances[i] = balanceOf(user, tokenIds[i]);
        }

        return balances;
    }

    function cancelProposal(uint256 proposalId) public onlyAdmin {
        Proposal storage proposal = proposals[proposalId];
        require(proposal.status == ProposalStatus.Pending, "Byte$: Proposal is not pending and cannot be cancelled");

        proposal.status = ProposalStatus.Cancelled;
        emit ProposalExecuted(proposal.id, proposal.ownerA, proposal.amount);
    }

    function setAdmin(address newAdmin) public onlyAdmin {
        require(newAdmin != address(0), "Byte$: New admin is the zero address");
        admin = newAdmin;
    }

    function updateRewardRate(uint256 newRate) public onlyAdmin {
        require(newRate > 0, "Byte$: Reward rate must be greater than zero");
        _stakingRewardRate = newRate;
        emit StakingRewardRateUpdated(newRate);
    }

    function stake(uint256 amount) public noReentrancy {
        require(amount > 0, "Byte$: Stake amount must be greater than zero");
        require(balanceOf(msg.sender, 0) >= amount, "Byte$: Insufficient balance for staking");
        require(_stakingBalances[msg.sender] + amount <= _maxStakePerValidator, "Byte$: Exceeds maximum staking limit");

        _stakingBalances[msg.sender] += amount;
        _stakingTimestamps[msg.sender] = block.timestamp;
        emit Stake(msg.sender, amount);
    }

    function withdrawStake() public noReentrancy {
        uint256 stakedAmount = _stakingBalances[msg.sender];
        require(stakedAmount > 0, "Byte$: No staked tokens found");
        require (block.timestamp >= _stakingTimestamps[msg.sender] + 120 days, "Byte$: Minimum staking period of 4 months not reached");

        uint256 reward = calculateStakeReward(msg.sender);
        uint256 totalAmount = stakedAmount + reward;

        _stakingBalances[msg.sender] = 0;
        emit WithdrawStake(msg.sender, totalAmount);
    }

    function calculateStakeReward(address staker) public view returns (uint256) {
        uint256 stakedAmount = _stakingBalances[staker];
        uint256 duration = block.timestamp - _stakingTimestamps[staker];

        uint256 rewardRate;
        if (stakedAmount < 999 * 10 ** _decimals) {
            rewardRate = 150;
        } else if (stakedAmount < 5000 * 10 ** _decimals) {
            rewardRate = 200;
        } else if (stakedAmount < 25000 * 10 ** _decimals) {
            rewardRate = 230;
        } else if (stakedAmount < 100000 * 10 ** _decimals) {
            rewardRate = 180;
        } else if (stakedAmount < 10000000 * 10 ** _decimals) {
            rewardRate = 150;
        } else {
            rewardRate = 100;
        }

        return (stakedAmount * rewardRate * duration) / (30 days * 100);
    }

    function createProposal(string memory description, uint256 duration, uint256 amount, address ownerA, address ownerB) public onlyAdmin noReentrancy {
        require(bytes(description).length > 0, "Byte$: Proposal description cannot be empty");
        require(amount > 0, "Byte$: Amount must be greater than zero");
        require(ownerA != address(0) && ownerB != address(0), "Byte$: Invalid owner addresses");

        proposalCount++;
        proposals[proposalCount] = Proposal({
            id: proposalCount,
            description: description,
            votesFor: 0,
            votesAgainst: 0,
            deadline: block.timestamp + duration,
            executed: false,
            amount: amount,
            ownerA: ownerA,
            ownerB: ownerB,
            status: ProposalStatus.Pending
        });
        emit ProposalCreated(proposalCount, description, block.timestamp + duration);
    }

    function voteOnProposal(uint256 proposalId, bool support) public noReentrancy {
        Proposal storage proposal = proposals[proposalId];
        require(block.timestamp < proposal.deadline, "Byte$: Voting period ended");
        require(!_hasVoted[proposalId][msg.sender], "Byte$: Already voted");

        uint256 votingPower = sqrt(balanceOf(msg.sender, 0));
        if (support) {
            proposal.votesFor += votingPower;
        } else {
            proposal.votesAgainst += votingPower;
        }

        _hasVoted[proposalId][msg.sender] = true;
        emit Voted(proposalId, msg.sender, support);

        // Check and execute proposal automatically after voting
        if (block.timestamp >= proposal.deadline) {
            if (proposal.votesFor > proposal.votesAgainst) {
                require(address(this).balance >= proposal.amount, "Byte$: Insufficient balance to execute the proposal");

                uint256 burnAmount = (proposal.amount * 3) / 100;
                uint256 transferAmount = proposal.amount - burnAmount;

                if (burnAmount > 0) {
                    _burn(blueFund, 0, burnAmount);
                    emit TokensBurned(blueFund, burnAmount);
                }

                payable(proposal.ownerA).transfer(transferAmount);
                proposal.executed = true;
                proposal.status = ProposalStatus.Executed;
                emit ProposalExecuted(proposal.id, proposal.ownerA, transferAmount);
            } else {
                proposal.status = ProposalStatus.Executed;
            }
            emit ProposalAutomaticallyExecuted(proposal.id, proposal.ownerA, proposal.amount);
        }
    }

    function sqrt(uint256 x) internal pure returns (uint256) {
        uint256 z = (x + 1) / 2;
        uint256 y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
        return y;
    }

    function setUserInfo(string memory avatar, string memory userName, bool isPublic) public noReentrancy {
        require(bytes(avatar).length > 0, "Byte$: Avatar cannot be empty");
        require(bytes(userName).length > 0, "Byte$: Name cannot be empty");
        require(!_nameExists[userName], "Byte$: Name already taken");
        require(!_avatarNameExists[avatar], "Byte$: Avatar name already taken");
        require(_avatarCount[msg.sender] < 1, "Byte$: Maximum of 1 avatars allowed");
        
        uint256 avatarId = uint256(keccak256(abi.encodePacked(msg.sender, avatar, block.timestamp)));
        _mint(msg.sender, avatarId, 1, "");
        _avatarIds[msg.sender] = avatarId;

        emit AvatarMinted(msg.sender, avatarId);
        
        _avatars[msg.sender] = avatar;
        _names[msg.sender] = userName;
        _isNamePublic[msg.sender] = isPublic;
        _nameExists[userName] = true;
        _avatarNameExists[avatar] = true;
        
        _avatarCount[msg.sender]++;
        _lastActive[msg.sender] = block.timestamp;
        
        emit UserInfoUpdated(msg.sender, avatar, userName, isPublic);
        
        if (!usuariosPremium[msg.sender]) {
            usuariosPremium[msg.sender] = true;
            emit UsuarioPremiumDefinido(msg.sender);
        }

        // Verificação de avatares inativos
        if (block.timestamp - _lastActive[msg.sender] > 5 * 365 days) {
            uint256 balance = balanceOf(msg.sender, avatarId);
            if (balance > 0) {
                _burn(msg.sender, avatarId, balance);
                _mint(blueFund, avatarId, balance, ""); 
                emit TokensBurned(msg.sender, balance);
            }
        }
    }

    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes memory data) public override {
        uint256 burnAmount = amount / 10000;
        uint256 transferAmount = amount - burnAmount; 
        
        if (burnAmount > 0) {
            _burn(from, id, burnAmount);
            emit TokensBurned(from, burnAmount); 
        }
        
        super.safeTransferFrom(from, to, id, transferAmount, data);
    }

    receive() external payable {}
}