const admin = require('firebase-admin');
const crypto = require('crypto');

// 庁 Configuraﾃｧﾃ｣o: Certifique-se de definir a variﾃ｡vel de ambiente FIREBASE_ADMIN_CREDENTIALS no seu provedor (Vercel).
// O valor deve ser o conteﾃｺdo JSON do arquivo de chave privada do Admin SDK, convertido em uma string.
if (!admin.apps.length) {
  try {
    // Tenta carregar as credenciais da variﾃ｡vel de ambiente (necessﾃ｡rio para a Vercel)
    const serviceAccount = JSON.parse(process.env.FIREBASE_ADMIN_CREDENTIALS);
    admin.initializeApp({
      credential: admin.credential.cert(serviceAccount)
    });
  } catch (error) {
    console.error('Falha ao inicializar o Firebase Admin SDK. Verifique a variﾃ｡vel FIREBASE_ADMIN_CREDENTIALS.', error);
    // Em um ambiente de produﾃｧﾃ｣o real, vocﾃｪ deve retornar um erro 500 aqui se a inicializaﾃｧﾃ｣o falhar.
  }
}

const db = admin.firestore();

// Funﾃｧﾃ｣o para calcular SHA256 (igual ﾃ do cliente)
const sha256 = (data) => {
    return crypto.createHash('sha256').update(data).digest('hex');
};

module.exports = async (req, res) => {
    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Mﾃｩtodo nﾃ｣o permitido.' });
    }

    // 1. Receber e validar dados essenciais
    const { 
        ticket, 
        nonce, 
        hash, 
        level, 
        invite, 
        previousHash, 
        userId // O ID do Firebase Auth do cliente
    } = req.body;

    if (!ticket || nonce === undefined || !hash || !level || !previousHash || !userId) {
        return res.status(400).json({ error: 'Dados incompletos fornecidos.' });
    }

    const levelInt = parseInt(level);
    const target = '0'.repeat(levelInt);

    try {
        // 2. VERIFICAﾃﾃグ CRIPTOGRﾃ：ICA DO POW
        
        // **IMPORTANTE:** A ordem de concatenaﾃｧﾃ｣o deve ser EXATAMENTE a mesma do seu cﾃｳdigo JavaScript no cliente.
        const dataToHash = previousHash + ticket + invite + nonce;
        const calculatedHash = sha256(dataToHash);
        
        // 2a. Validar Hash e Dificuldade (a seguranﾃｧa principal)
        if (calculatedHash !== hash || !calculatedHash.startsWith(target)) {
            return res.status(401).json({ error: 'O Hash enviado nﾃ｣o ﾃｩ vﾃ｡lido ou nﾃ｣o atinge o nﾃｭvel de dificuldade requerido.' });
        }

        // 3. VERIFICAﾃﾃグ DE REPLAY (ANTI-CHEAT)
        // 3a. Checa se este Hash Vﾃ｡lido jﾃ｡ foi usado (impede que o mesmo PoW seja submetido mﾃｺltiplas vezes)
        const replayCheck = await db.collection('blocks').where('hash', '==', hash).limit(1).get();
        if (!replayCheck.empty) {
            return res.status(409).json({ error: 'O Hash Vﾃ｡lido (prova de trabalho) jﾃ｡ foi registrado. Reutilizaﾃｧﾃ｣o de token detectada.' });
        }
        
        // 3b. Opcional: Verificar se o Hash Anterior existe (ajuda a garantir a integridade da cadeia)
        // Se previousHash nﾃ｣o for "Gﾃｪnesis" ('0'.repeat(64)), ele deve ser um Hash Vﾃ｡lido existente.
        if (!previousHash.startsWith('0'.repeat(64))) {
             const blockCheck = await db.collection('blocks').where('hash', '==', previousHash).limit(1).get();
             if (blockCheck.empty) {
                 // Esta ﾃｩ uma checagem de integridade forte. Remova-a se quiser blocos "ﾃｳrfﾃ｣os".
                 // return res.status(409).json({ error: 'Hash do Bloco Anterior nﾃ｣o encontrado na cadeia. Tentativa de mineraﾃｧﾃ｣o fora da ordem.' });
             }
        }

        // 4. GERAﾃﾃグ E REGISTRO DO TOKEN (+Byt3S)
        const tokenLength = 20; 
        const byt3Token = hash.substring(levelInt, levelInt + tokenLength); 
        
        const newBlock = {
            userId: userId,
            ticket: ticket,
            invite: invite,
            level: levelInt,
            nonce: nonce,
            previousHash: previousHash,
            hash: hash,
            byt3Token: byt3Token,
            timestamp: admin.firestore.FieldValue.serverTimestamp()
        };

        // Salvar no Firestore
        await db.collection('blocks').add(newBlock);

        // 5. RESPOSTA DE SUCESSO
        return res.status(200).json({ 
            success: true, 
            message: 'Mineraﾃｧﾃ｣o validada e bloco registrado com sucesso!',
            byt3Token: byt3Token,
            hash: hash
        });

    } catch (error) {
        console.error('Erro de Servidor:', error);
        return res.status(500).json({ error: 'Erro interno do servidor.' });
    }
};